"use strict";(self.webpackChunkapplitools_playwright_docs=self.webpackChunkapplitools_playwright_docs||[]).push([[596],{6180:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var i=s(4848),t=s(8453);const a={},l="Maintaining Visual Tests Over Time",r={id:"guides/maintaining-tests",title:"Maintaining Visual Tests Over Time",description:"Maintaining visual tests is crucial to ensure they remain effective and relevant as your application evolves. This guide provides strategies and best practices for managing visual tests over time, handling intentional UI changes, and keeping your test suite maintainable and reliable.",source:"@site/docs/guides/maintaining-tests.md",sourceDirName:"guides",slug:"/guides/maintaining-tests",permalink:"/applitools-playwright-docs/docs/guides/maintaining-tests",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"CI/CD Integration",permalink:"/applitools-playwright-docs/docs/ci-cd-integration"},next:{title:"Conducting Code Reviews with Visual Test Results",permalink:"/applitools-playwright-docs/docs/guides/code-reviews"}},o={},c=[{value:"The Importance of maintenance",id:"the-importance-of-maintenance",level:2},{value:"Strategies for updating baselines",id:"strategies-for-updating-baselines",level:2},{value:"1. Review changes regularly",id:"1-review-changes-regularly",level:3},{value:"2. Use batch approvals",id:"2-use-batch-approvals",level:3},{value:"3. Leverage version control",id:"3-leverage-version-control",level:3},{value:"Handling intentional UI changes",id:"handling-intentional-ui-changes",level:2},{value:"1. Communicate changes early",id:"1-communicate-changes-early",level:3},{value:"2. Update baselines proactively",id:"2-update-baselines-proactively",level:3},{value:"3. Annotate changes",id:"3-annotate-changes",level:3},{value:"Best practices for baseline management",id:"best-practices-for-baseline-management",level:2},{value:"Keep baselines clean and organized",id:"keep-baselines-clean-and-organized",level:3},{value:"Avoid over-updating baselines",id:"avoid-over-updating-baselines",level:3},{value:"Use ignore regions wisely",id:"use-ignore-regions-wisely",level:3},{value:"Implementing maintenance in your workflow",id:"implementing-maintenance-in-your-workflow",level:2},{value:"Integrate with CI/CD pipelines",id:"integrate-with-cicd-pipelines",level:3},{value:"Establish ownership",id:"establish-ownership",level:3},{value:"Monitor test stability",id:"monitor-test-stability",level:3},{value:"Tips for long-term success",id:"tips-for-long-term-success",level:2},{value:"Educate the team",id:"educate-the-team",level:3},{value:"Regular audits",id:"regular-audits",level:3},{value:"Stay updated with Applitools features",id:"stay-updated-with-applitools-features",level:3}];function d(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"maintaining-visual-tests-over-time",children:"Maintaining Visual Tests Over Time"})}),"\n",(0,i.jsx)(n.p,{children:"Maintaining visual tests is crucial to ensure they remain effective and relevant as your application evolves. This guide provides strategies and best practices for managing visual tests over time, handling intentional UI changes, and keeping your test suite maintainable and reliable."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"the-importance-of-maintenance",children:"The Importance of maintenance"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Adaptation"}),": Your application's UI will change due to new features, redesigns, or updates."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Accuracy"}),": Regular maintenance ensures your visual tests accurately reflect the current state of your application."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficiency"}),": Proactive management reduces false positives and unnecessary debugging."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"strategies-for-updating-baselines",children:"Strategies for updating baselines"}),"\n",(0,i.jsx)(n.p,{children:"Baselines are the reference images used for visual comparisons. When intentional UI changes occur, you'll need to update these baselines."}),"\n",(0,i.jsx)(n.h3,{id:"1-review-changes-regularly",children:"1. Review changes regularly"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Schedule reviews"}),": Establish a routine (e.g., after each sprint) to review visual test results."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Collaborate"}),": Involve developers, testers, and designers in the review process to ensure changes are intentional and acceptable."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-use-batch-approvals",children:"2. Use batch approvals"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Batch updates"}),": When multiple tests are affected by a UI change, use batch operations in the Applitools Dashboard to approve all related changes efficiently."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistency"}),": Ensure that all affected baselines are updated simultaneously to prevent inconsistencies."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-leverage-version-control",children:"3. Leverage version control"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Branch-specific baselines"}),": Utilize Applitools' branching features to manage baselines per feature branch."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Merge strategies"}),": When merging branches, merge corresponding baselines to keep the main branch up-to-date."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"handling-intentional-ui-changes",children:"Handling intentional UI changes"}),"\n",(0,i.jsx)(n.p,{children:"When intentional UI updates occur, it's essential to manage visual tests to reflect these changes accurately."}),"\n",(0,i.jsx)(n.h3,{id:"1-communicate-changes-early",children:"1. Communicate changes early"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Design Documentation"}),": Keep design specifications updated and accessible."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Team Notifications"}),": Inform the testing team of upcoming UI changes to prepare for baseline updates."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-update-baselines-proactively",children:"2. Update baselines proactively"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pre-update baselines"}),": Before merging UI changes into the main branch, run visual tests and update baselines accordingly."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Staging environments"}),": Use staging environments to validate UI changes and update baselines before production deployment."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-annotate-changes",children:"3. Annotate changes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Remarks and issues"}),": Use the Applitools Dashboard to add remarks explaining the nature of intentional changes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Change history"}),": Maintain a log of changes for future reference."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-for-baseline-management",children:"Best practices for baseline management"}),"\n",(0,i.jsx)(n.h3,{id:"keep-baselines-clean-and-organized",children:"Keep baselines clean and organized"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Naming conventions"}),": Use descriptive and consistent names for tests and baselines."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Archive old baselines"}),": Remove or archive outdated baselines to reduce clutter."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"avoid-over-updating-baselines",children:"Avoid over-updating baselines"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Verify changes"}),": Ensure that changes are indeed intentional before updating baselines."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Partial updates"}),": Update only the affected areas when possible, rather than the entire baseline."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"use-ignore-regions-wisely",children:"Use ignore regions wisely"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic content"}),": Apply ignore regions to areas with frequently changing content to reduce false positives."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"balance"}),": Avoid overusing ignore regions, as they may mask unintended changes."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"implementing-maintenance-in-your-workflow",children:"Implementing maintenance in your workflow"}),"\n",(0,i.jsx)(n.h3,{id:"integrate-with-cicd-pipelines",children:"Integrate with CI/CD pipelines"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automated testing"}),": Run visual tests automatically during builds to catch issues early."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Notifications"}),": Configure alerts for test failures to prompt timely reviews."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"establish-ownership",children:"Establish ownership"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Assign responsibilities"}),": Designate team members responsible for reviewing and updating baselines."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Collaborative tools"}),": Utilize tools like the Applitools Dashboard to facilitate teamwork."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"monitor-test-stability",children:"Monitor test stability"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Flaky tests"}),": Identify and address tests that frequently fail due to environmental issues."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistent environments"}),": Ensure testing environments are stable and consistent to reduce false positives."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"tips-for-long-term-success",children:"Tips for long-term success"}),"\n",(0,i.jsx)(n.h3,{id:"educate-the-team",children:"Educate the team"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Training"}),": Provide training on visual testing best practices and tools."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Guidelines"}),": Develop documentation outlining processes for maintaining visual tests."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"regular-audits",children:"Regular audits"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Review test coverage"}),": Periodically assess which areas are being tested visually and adjust as needed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Optimize performance"}),": Remove redundant tests and focus on high-impact areas."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"stay-updated-with-applitools-features",children:"Stay updated with Applitools features"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"New capabilities"}),": Keep an eye on updates to Applitools that could enhance your maintenance process."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Community engagement"}),": Participate in forums or user groups to learn from others' experiences."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>r});var i=s(6540);const t={},a=i.createContext(t);function l(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);